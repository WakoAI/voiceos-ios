//
// CallResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct CallResponse: Codable, JSONEncodable, Hashable {

    /** The uri of the conversation. */
    public var uri: String
    /** The type of the call. */
    public var type: CallType
    /** The status of the conversation (live or ended). */
    public var status: CallStatus
    /** The phone number that the call is going to. */
    public var toNumber: String?
    /** The phone number that call is coming from. */
    public var fromNumber: String?
    /** The start time of the conversation. */
    public var startTime: Date
    /** The end time of the conversation. */
    public var endTime: Date?
    /** The agent used for the call. */
    public var agent: AgentResponse
    /** The id of the agent used in the call. Returns null if the call did not use an existing agent. */
    public var agentId: String?
    /** The messages of the conversation. */
    public var messages: [Message]?
    /** The account id associated with of the conversation. */
    public var accountId: String
    /** The reasons the conversation ended. */
    public var endedReason: EndedReasons?
    /** The cost of the conversation. */
    public var cost: CallCost?
    /** The id of the conversation. */
    public var id: String

    public init(uri: String, type: CallType, status: CallStatus, toNumber: String? = nil, fromNumber: String? = nil, startTime: Date, endTime: Date? = nil, agent: AgentResponse, agentId: String? = nil, messages: [Message]? = nil, accountId: String, endedReason: EndedReasons? = nil, cost: CallCost? = nil, id: String) {
        self.uri = uri
        self.type = type
        self.status = status
        self.toNumber = toNumber
        self.fromNumber = fromNumber
        self.startTime = startTime
        self.endTime = endTime
        self.agent = agent
        self.agentId = agentId
        self.messages = messages
        self.accountId = accountId
        self.endedReason = endedReason
        self.cost = cost
        self.id = id
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case uri
        case type
        case status
        case toNumber = "to_number"
        case fromNumber = "from_number"
        case startTime = "start_time"
        case endTime = "end_time"
        case agent
        case agentId = "agent_id"
        case messages
        case accountId = "account_id"
        case endedReason = "ended_reason"
        case cost
        case id
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(uri, forKey: .uri)
        try container.encode(type, forKey: .type)
        try container.encode(status, forKey: .status)
        try container.encodeIfPresent(toNumber, forKey: .toNumber)
        try container.encodeIfPresent(fromNumber, forKey: .fromNumber)
        try container.encode(startTime, forKey: .startTime)
        try container.encodeIfPresent(endTime, forKey: .endTime)
        try container.encode(agent, forKey: .agent)
        try container.encodeIfPresent(agentId, forKey: .agentId)
        try container.encodeIfPresent(messages, forKey: .messages)
        try container.encode(accountId, forKey: .accountId)
        try container.encodeIfPresent(endedReason, forKey: .endedReason)
        try container.encodeIfPresent(cost, forKey: .cost)
        try container.encode(id, forKey: .id)
    }
}

